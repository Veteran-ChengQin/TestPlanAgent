import json
import time
import requests
import random

def llm(system_prompt, user_prompt, model):
    """
    用给定的提示调用语言模型API。
    
    Args:
        system_prompt (str): 系统提示为LLM
        user_prompt (str, optional): 用户提示llm
        model (str): 模型名称
        
    Returns:
        str: LLM响应内容
    """
    if 'deepseek' in model:
        api_key = "sk-da7a5e373876461f9efb80e7c15828a5"
        url = "https://api.deepseek.com/chat/completions"
        
    elif 'qwen' in model:
        api_key = "sk-6072ffbc181542f2862a1fd04d8291c0"
        url = "http://localhost:8000/v1/chat/completions"
    else:
        api_key = "sk-wvvB8thiOVcpwJw1i4OI4FqFSItWyC5IePz3hAgrOJ0Jh1MY"
        # if 'claude' in model:
        #     url = "https://api.gptsapi.net/v1/messages"
        # else:
        url = "https://api.chatanywhere.tech/v1/chat/completions"

    
    headers = {
        "Authorization": f"Bearer {api_key}",
        "Content-Type": "application/json"
    }
    
    # if 'claude' in model:
    #     data = {
    #         "model": model,
    #         "system": system_prompt,
    #         "messages": [
    #             {"role": "user", "content": user_prompt}
    #         ]
    #     }
    # else:    
    data = {
        "model": model,
        "messages": [
            {"role": "system", "content": system_prompt},
            {"role": "user", "content": user_prompt}
        ],
        # "seed": 1234
        # "temperature ": 0.2
    }
    
    max_retries = 5
    response = None
    for attempt in range(max_retries):
        try:
            response = requests.post(url, json=data, headers=headers)
            response.raise_for_status()
            break
        except requests.exceptions.RequestException as e:
            if attempt < max_retries - 1:
                print(f"Request failed. Retrying... (Attempt {attempt + 1}/{max_retries})")
                time.sleep(2 ** attempt)
                continue
            else:
                print(e)
                raise e
    
    if response is None:
        raise Exception("All retry attempts failed")
    
    response_dict = json.loads(response.text.strip())
    if 'claude' in model:
        content = response_dict["content"][0]["text"]
    else:    
        content = response_dict['choices'][0]['message']['content']
    return content

def main():
    # 定义10个英文问
    
    model = "qwen-coder-14B"  # 设置默认模型
    # system_prompt = "You are a professional Q&A assistant. Please provide detailed, accurate, and insightful answers to the user's questions."
    system_prompt = '''\nYou are an automated Test Plan Generation Agent for a GitHub Pull Request.\nYour objective is to create a comprehensive test plan for the given Pull Request.\n\nYou have been provided with:\n1. The PR description and changed files\n2. The git diff formatted code where the current PR has changed\n\nUsing this information, create a comprehensive test plan in the following format:\n\n### Test Plan Details:\n```\n# Test Plan for PR: [PR Title/Number]\n\n## 1. Purpose\n[Briefly explain the purpose of this test plan - what functionality is being tested and why]\n\n## 2. Scope\n[Define what is in scope and out of scope for this test plan, based on the PR changes]\n\n## 3. Test Environment\n[Specify required environment setup, configurations, dependencies, and prerequisites needed]\n\n## 4. Test Cases\n[Organize test cases by component or feature. For each test case, include:\n- Test case ID/name\n- Test objective\n- Preconditions\n- Test steps (numbered, clear instructions)\n- Expected results\n- Priority (High/Medium/Low)]\n\n```\n   \n# TIPS:\n- Prioritize tests based on risk and complexity of changes\n- Include both positive test cases (expected behavior) and negative test cases (error handling)\n- Your test plan should be specific enough for any tester to follow without requiring additional information\n- Strive for accuracy, clarity, and completeness in your test plan\n\n'''
    user_prompt = '''
    \nPlease help me create a comprehensive test plan for this pull request (PR). The test plan should follow IEEE software testing standards and include purpose, scope, environment, test cases, and expected results.\n\n## PR Description:\nfeat(Integrations): Send Metric Alerts in MS Teams\n## Objective\nWe want to view Metric Alerts in Microsoft Teams. It should have similar functionality and style to the Slack implementation.\n\n## UI\n<img width= \"976 \" alt= \"Screen Shot 2020-08-11 at 5 59 29 PM \" src= \"https://user-images.githubusercontent.com/10491193/89963410-6d498e00-dbfc-11ea-8855-4e37fba53206.png \">\n\n\n## Summaries of the changed functions/classes in the current PR:\n{\"code_changes_summary\": [{\"src/sentry/integrations/slack/utils.py\": [\"The summary of `build_incident_attachment` function is: \\nThis function, `build_incident_attachment`, constructs a Slack attachment object for unfurling incident details. It takes an `Incident` object and an optional `metric_value` parameter, which represents the metric that triggered the alert; if not provided, the function attempts to calculate it internally. The function uses the incident's status to determine the attachment's color and populates fields such as title, text, timestamp, and footer with relevant incident data. It returns a dictionary formatted for Slack, with no side effects, and is primarily used for integrating incident information into Slack notifications.\\n\"]}, {\"src/sentry/testutils/cases.py\": [\"The summary of `now` function is: \\nThis function `now` returns the current time in the system's timezone, truncated to the hour by setting the minute, second, and microsecond values to zero. It is useful for operations requiring hour-level granularity and avoids finer time precision. There are no side effects, and it relies on the `timezone.now()` method for obtaining the current time.\\n\", \"The summary of `BaseIncidentsTest` class is: \\n### Summary of `BaseIncidentsTest` Class\\n\\nThe `BaseIncidentsTest` class extends `SnubaTestCase` and serves as a utility base for testing incidents-related functionality. It provides helper methods to streamline the creation of test events and manage timestamps for consistent test scenarios.\\n\\n- **`create_event` Method**: Facilitates the creation and storage of test events with customizable attributes such as `timestamp`, `fingerprint`, and `user`. It ensures the event payload adheres to required formats, including the inclusion of an exception for error-type events. Returns the stored event object, with potential side effects on the underlying event storage system.\\n- **`now` Property**: Provides a cached timestamp representing the current time, rounded to the nearest hour, for consistent use across tests.\\n\\nThis class plays a foundational role in incident-related test cases by abstracting common setup tasks and ensuring data integrity for test events.\\n\", \"The summary of `create_event` function is: \\nThis function, `create_event`, generates and stores an error event in the system. It creates a unique `event_id` using a UUID and uses it as the default fingerprint unless one is provided. The event data includes a timestamp (formatted as ISO), a mandatory exception payload, and optional user information. It returns the result of storing the event via `self.store_event`, which associates the event with the current project's ID. Notable constraints include the requirement for an exception in the payload for \\\"error\\\" type events.\\n\"]}, {\"tests/sentry/incidents/test_logic.py\": [\"The summary of `now` function is: \\nThis function `now` returns the current time in the system's timezone, truncated to the nearest hour by setting the minute, second, and microsecond components to zero. It ensures consistent hourly precision for time-related operations and relies on the `timezone.now()` method for timezone-aware datetime retrieval.\\n\", \"The summary of `create_event` function is: \\nThis function, `create_event`, generates and stores an error event with a unique identifier (`event_id`) and customizable attributes such as `timestamp`, `fingerprint`, and `user`. It ensures the event includes a default exception payload and formats the timestamp using `iso_format`. The function returns the result of storing the event via `self.store_event`, which associates the event with the current project's ID. Notable constraints include the mandatory inclusion of an exception payload for error-type events.\\n\", \"The summary of `BaseIncidentsTest` class is: \\n### Summary of `BaseIncidentsTest` Class\\n\\nThe `BaseIncidentsTest` class extends `SnubaTestCase` and serves as a utility for testing incidents-related functionality. It provides methods and properties to create mock events and manage test data for incident scenarios.\\n\\n- **`create_event` Method**: Generates and stores a mock event with customizable attributes such as `timestamp`, `fingerprint`, and `user`. It ensures the event adheres to the required structure, including an exception payload for error-type events. Returns the stored event object, with potential side effects on the test database.\\n- **`now` Property**: Provides a cached timestamp representing the current time, rounded to the nearest hour, for consistent use across tests.\\n\\nThis class is integral to testing systems that rely on event data, ensuring accurate and reproducible test cases for incidents-related features.\\n\"]}, {\"tests/sentry/incidents/test_action_handlers.py\": [\"The summary of `MsTeamsActionHandlerFireTest` class is: \\nThis test class, `MsTeamsActionHandlerFireTest`, extends `MsTeamsActionHandlerBaseTest` and `TestCase` to validate the behavior of firing an incident in the Microsoft Teams action handler. The `test` method creates an alert rule and an incident with a status of 2 (indicating \\\"firing\\\"), and then runs a test with the incident and the action type \\\"fire\\\". It ensures that the system correctly handles and processes incidents in the \\\"fire\\\" state, but does not include assertions or detailed validation logic within this snippet.\\n\", \"The summary of `run_test` function is: \\nThe `run_test` function is a test utility designed to simulate and validate the behavior of Microsoft Teams alert actions in the Sentry integration system. It creates a mock `Integration` object for Microsoft Teams, configures a test alert rule trigger action, and uses the `MsTeamsActionHandler` to execute a specified method (`method`) with a test incident and metric value. \\n\\nKey parameters include `incident` (the incident being tested) and `method` (the handler method to invoke). The function uses mocked HTTP responses to simulate API interactions with Microsoft Teams, ensuring that the generated incident attachment matches the expected format. Notable side effects include the creation of test objects and the use of mocked network calls, making it suitable for isolated testing scenarios.\\n\", \"The summary of `test` function is: \\nThis `test` function is designed to validate the behavior of an alerting system by creating an alert rule and an incident with a predefined status (`2`), then executing a test using the `run_test` method with the incident and a \\\"fire\\\" condition. It relies on helper methods (`create_alert_rule` and `create_incident`) to set up the necessary test data. The function has no return value and serves as a procedural test within a larger testing framework.\\n\", \"The summary of `MsTeamsActionHandlerBaseTest` class is: \\n### Summary of `MsTeamsActionHandlerBaseTest`\\n\\nThis test class is designed to validate the behavior of the `MsTeamsActionHandler` in the context of handling Microsoft Teams alert actions for incidents. The `run_test` method sets up a mock integration with Microsoft Teams, including service URL, access token, and organization linkage, and simulates API responses for retrieving channels and posting messages. It then creates an alert rule trigger action and invokes a specified method (`method`) on the `MsTeamsActionHandler` instance to test its functionality.\\n\\nKey parameters include `incident` (the incident being handled), `method` (the handler method to test), and `metric_value` (used for incident attachment generation). The method verifies that the generated message payload matches the expected incident attachment structure. Notable side effects include mocking external API calls and ensuring proper integration setup. This test plays a critical role in ensuring the correctness of Microsoft Teams alert handling within the larger system.\\n\", \"The summary of `SlackActionHandlerBaseTest` class is: \\n### Summary of `SlackActionHandlerBaseTest`\\n\\nThis test class is designed to validate the functionality of Slack integration handlers in the context of incident management within the Sentry system. Specifically, the `run_test` method simulates the behavior of sending Slack messages triggered by alert rules, ensuring that the correct API calls are made and the expected data is sent.\\n\\n- **Purpose**: The `run_test` method tests the integration between Sentry's alerting system and Slack by mocking API responses and verifying that the SlackActionHandler processes incidents correctly.\\n- **Key Parameters**: \\n  - `incident`: Represents the incident triggering the Slack action.\\n  - `method`: Specifies the handler method to invoke (e.g., `fire` or `resolve`).\\n- **Key Behaviors**:\\n  - Creates a mock Slack integration and associates it with an organization and user.\\n  - Simulates Slack API responses for channel listing and message posting.\\n  - Verifies that the handler sends the correct channel ID, token, and incident attachment data in the API request.\\n- **Notable Constraints**: Requires mocked API responses (`responses` library) and assumes the presence of specific Sentry models and utilities (e.g., `Integration`, `build_incident_attachment`).\\n- **Role in System**: Ensures the reliability and correctness of Slack alert actions, a critical feature for notifying users about incidents in real-time.\\n\"]}, {\"tests/sentry/integrations/test_metric_alerts.py\": [\"The summary of `test_with_incident_trigger` function is: \\nThis function, `test_with_incident_trigger`, is a test case designed to validate the behavior of incident-related functionality in a system. It creates an alert rule, generates multiple events, and simulates the creation of an incident with a closed status. The function then associates a trigger action with the incident, updates the trigger's modification timestamp, and retrieves incident-related data using `incident_attachment_info`.\\n\\nKey behaviors include verifying the correctness of the incident's metadata (e.g., title, status, event count, timestamps, and links) against expected values. The function ensures that the system correctly formats and provides incident-related information for downstream use, such as notifications. It operates within a test environment and assumes predefined methods like `create_alert_rule`, `create_event`, and `create_incident`.\\n\", \"The summary of `test_returns_correct_info` function is: \\nThis test function, `test_returns_correct_info`, verifies the correctness of the data returned by the `incident_attachment_info` function. It creates an alert rule and an incident with specific attributes (e.g., status, date started, and associated projects), then checks that the generated attachment data matches expected values for fields such as title, status, text, timestamp, and URLs. The test ensures proper formatting and linkage of incident-related information, and it relies on mock data and predefined system behaviors.\\n\", \"The summary of `IncidentAttachmentInfoTest` class is: \\n### Summary of `IncidentAttachmentInfoTest` Class\\n\\nThe `IncidentAttachmentInfoTest` class is a test suite designed to validate the behavior of the `incident_attachment_info` function, ensuring it generates correct metadata for incidents in the system. It inherits from `TestCase` and `BaseIncidentsTest`, leveraging shared utilities for creating incidents, alert rules, and related entities.\\n\\n- **Purpose**: To verify that the `incident_attachment_info` function produces accurate and consistent data for incident attachments, including title, status, text, timestamps, and URLs.\\n- **Key Behaviors**:\\n  - The `test_returns_correct_info` method checks the function's output for a resolved incident, ensuring proper formatting of metadata such as event counts and links.\\n  - The `test_with_incident_trigger` method tests the function's behavior when an incident trigger is involved, validating the handling of event counts and timestamps.\\n- **Role in the System**: This class ensures the reliability of incident-related metadata generation, which is critical for displaying incident information in external systems, such as notifications or dashboards.\\n\\nNo notable side effects are present, but the tests assume the existence of helper methods like `create_alert_rule`, `create_incident`, and `create_event`, as well as a functioning database for querying and updating incident triggers.\\n\"]}, {\"src/sentry/integrations/msteams/utils.py\": [\"The summary of `send_incident_alert_notification` function is: \\nThis function, `send_incident_alert_notification`, sends an alert notification about an incident to a Microsoft Teams channel. It takes three parameters: `action` (containing integration and target channel details), `incident` (the incident data), and `metric_value` (associated metric information). The function constructs an incident attachment using `build_incident_attachment` and sends it via the `MsTeamsClient`. If the API call fails, it logs the error without raising an exception. This function is integral for integrating incident alerts with Microsoft Teams, ensuring notifications are delivered to the specified channel.\\n\", \"The summary of `build_incident_attachment` function is: \\nThis function, `build_incident_attachment`, generates a structured Adaptive Card payload for representing incident information in a messaging or notification system. It takes an `incident` object and an optional `metric_value` as inputs, using them to construct a visually formatted card with details such as the incident's title, status, description, and timestamp. \\n\\nKey behaviors include:\\n- Dynamically assigning a color style based on the incident's status (`Resolved`, `Warning`, or `Critical`).\\n- Embedding metadata like a clickable title, descriptive text, and a footer with a timestamp.\\n- Incorporating a logo and other visual elements to enhance readability.\\n\\nThe function returns a dictionary conforming to the Adaptive Card schema (`version 1.3`) and has no side effects. It is designed for integration with systems that support Adaptive Cards, such as Microsoft Teams or other platforms.\\n\"]}, {\"src/sentry/incidents/action_handlers.py\": [\"The summary of `MsTeamsActionHandler` class is: \\n### `MsTeamsActionHandler` Class Summary:\\nThe `MsTeamsActionHandler` class extends the `ActionHandler` to manage alert notifications for Microsoft Teams. It provides methods (`fire` and `resolve`) to trigger and resolve alerts based on a `metric_value`, both of which internally call the `send_alert` method. The `send_alert` method utilizes the `send_incident_alert_notification` utility to send incident-related notifications to Microsoft Teams, leveraging the `action`, `incident`, and `metric_value` attributes. This class is designed to integrate seamlessly with Sentry's incident management system, ensuring alerts are communicated effectively via Microsoft Teams.\\n\"]}, {\"src/sentry/integrations/metric_alerts.py\": [\"The summary of `incident_attachment_info` function is: \\nThis function, `incident_attachment_info`, generates a structured dictionary containing metadata and descriptive information about a given incident, primarily for use in notifications or UI components. It calculates key details such as the incident's status, associated alert rule, metric value, and time window, while also constructing a title, text summary, and link to the incident's detailed view. \\n\\n### Key Parameters:\\n- **incident**: The incident object containing details about the alert and its context.\\n- **metric_value** *(optional)*: A precomputed metric value; if not provided, it is dynamically calculated based on the incident's aggregates.\\n\\n### Return Value:\\n- A dictionary with keys like `title`, `text`, `logo_url`, `status`, `ts`, and `title_link`, encapsulating the incident's summary and metadata.\\n\\n### Notable Behaviors:\\n- Dynamically computes the metric value and time window based on the incident's associated alert rule and triggers.\\n- Handles potential delays in trigger updates with a TODO note indicating a possible constraint.\\n- Constructs user-friendly text and title based on the incident's status and alert rule configuration.\\n\\n### Role in the System:\\nThis function is likely used to prepare incident data for rendering in notifications, dashboards, or external integrations, providing a concise and actionable summary of the incident's state and metrics.\\n\"]}]}\n\n## Your Task\n\nAs a software test manager, please:\n\n1. Analyze the PR description and summaries of the changed functions/classes to understand the purpose and scope of the changes.\n\n2. Create a structured test plan that includes:\n   - Purpose: What is being tested and why\n   - Scope: What specific functionality is covered and what is excluded\n   - Test Environment: Required setup and configurations\n   - Test Cases: Detailed test steps with expected results\n   - Special Considerations: Any edge cases, risks, or dependencies\n\n3. Focus on testing:\n   - New functionality introduced by the PR\n   - Modified components and their interactions\n   - Potential regression issues\n   - Edge cases and error handling\n\n4. Prioritize test cases based on:\n   - Risk level (critical path functionality)\n   - Complexity of changes\n   - Customer impact\n\nRemember to consider both positive testing (expected behavior) and negative testing (error handling) in your plan.\n",
    '''
    
    while True:
        try: 
            # 请求LLM回答
            result = llm(system_prompt, user_prompt, model)
            
            print(f"\nAnswer:")
            print(result)
        

        
        # time.sleep(5)
        
        except Exception as e:
            print(f"Error occurred: {e}")
            time.sleep(5)  # 出错时等待更长时间再重试
                # continue

if __name__ == "__main__":
    main()
